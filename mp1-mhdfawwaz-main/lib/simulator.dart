
import 'dart:collection';
import 'package:yaml/yaml.dart';
import 'processes.dart';

// A simulation framework for queuing systems, where singleton, periodic & stochastic process are executed 
class Simulator {
  final bool verbose; // Enables detailed output when set to true
  final List<Process> processes = []; // List of all processes being simulated
  final List<Event> eventQueue = []; // Queue holding events

  Simulator(YamlMap yamlData, {this.verbose = false}) {
    for (final name in yamlData.keys) {
      final fields = yamlData[name];
      
      switch (fields['type']) {

        case 'singleton': // A process that occurs only once

          processes.add(SingletonProcess(name, fields['duration'].toInt(), fields['arrival'].toInt()));
          break;

        case 'periodic':          // A process that occurs at regular intervals for a given number of repetitions

          processes.add(PeriodicProcess(
              name,
              fields['duration'].toInt(), fields['interarrival-time'].toInt(),
              fields['first-arrival'].toInt(), fields['num-repetitions'].toInt()));
          break;

        case 'stochastic':          // A process with randomly determined arrival and duration times

          processes.add(StochasticProcess(
              name,
              fields['mean-duration'].toDouble(), fields['mean-interarrival-time'].toDouble(),
              fields['first-arrival'].toInt(), fields['end'].toInt()));
          break;

        default:
          throw ArgumentError('Unknown process type: ${fields['type']}'); //throws when exception
      }
    }
  }

    // This runs the simulation by generating events from each process then sorting them by arrival time and processing in sequence.
  void run() {

    // Generate events from each process and add them to the event queue
    for (var process in processes) {
      eventQueue.addAll(process.generateEvents());
    }
    
    // Sort events so they are processed in the way of order of their arrival time
    eventQueue.sort((a, b) => a.arrivalTime.compareTo(b.arrivalTime));

    int currentTime = 0;            // Tracks the current time 
    
    
    for (var event in eventQueue) {    // Process each event, updating its start time, wait time, and advancing the time

      if (event.arrivalTime > currentTime) {

      // Move time forward to the next event's arrival if needed
        currentTime = event.arrivalTime;
      }
      event.startTime = currentTime;                     // Time when the event starts processing
      event.waitTime = currentTime - event.arrivalTime; // Calculating wait time
      currentTime += event.duration;                    // Move forward the time by the event's duration
      
      // Print event details, if the  "verbose" is enabled
      if (verbose) {
        print('t=${event.startTime}: ${event.processName}, duration ${event.duration} started '
            '(arrived @ ${event.arrivalTime}, waited ${event.waitTime})');
      }
    }
  }

    // Prints a report summarizing statistics for each process
  void printReport() {
    final Map<String, List<Event>> eventsByProcess = {}; // Grouping the events by the process name

    // Organize events into lists by process name
    for (var event in eventQueue) {
      eventsByProcess.putIfAbsent(event.processName, () => []).add(event);
    }

    // Print statistics of process
    print('\n# Per-process statistics');
    for (var processName in eventsByProcess.keys) {
      final events = eventsByProcess[processName]!;   //Looks up for the events
      final totalWaitTime = events.fold(0, (sum, event) => sum + event.waitTime); // Looks up for the total wait time
      final avgWaitTime = totalWaitTime / events.length; // Looks up for the average wait time

      print('$processName:');
      print('  Events generated:  ${events.length}'); //Prints the events generated by the processes
      print('  Total wait time:   $totalWaitTime'); //Print the total wait time of the processes
      print('  Average wait time: ${avgWaitTime.toStringAsFixed(2)}');  // Prints the average wait time of the processes with length of 2
    }

    // Summary of the simulation's statistics
    final totalEvents = eventQueue.length; //TotalEvents
    final totalWaitTime = eventQueue.fold(0, (sum, event) => sum + event.waitTime); //Total Waittime
    final avgWaitTime = totalWaitTime / totalEvents; // Average Waittime

    print('\n# Summary statistics');
    print('Total num events:  $totalEvents'); //Printing total number of events
    print('Total wait time:   $totalWaitTime');// Printing total wait time
    print('Average wait time: ${avgWaitTime.toStringAsFixed(2)}'); // Printing Average wait time
  }
}
